"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const send_1 = __importDefault(require("send"));
const content_disposition_1 = __importDefault(require("content-disposition"));
const htmlTemplate_1 = require("./utils/htmlTemplate");
/**
 * A wrapper around the `http.ServerResponse`
 */
class Response {
    constructor(res) {
        this.res = res;
        this.isBrowserRequest =
            this.res.req.headers["sec-fetch-dest"] == "document";
    }
    /**
     * A simple utility to set any Header
     * @param field The header that you want to set
     * @param value The value
     * @returns
     */
    set(field, value) {
        this.res.setHeader(field, value);
        return this;
    }
    /**
     * A simple utility to set any Header
     * @param field The header that you want to set
     * @param value The value
     * @returns
     */
    setHeader(field, value) {
        this.res.setHeader(field, value);
        return this;
    }
    /**
     * Send anything as response
     * @param message The content you want to send
     * @param cb Error handler (if anything goes wrong)
     * @returns
     */
    write(message, cb) {
        this.res.write(message, cb);
        return this;
    }
    /**
     * End the response and return once called nothing can be send to the client
     * @param cb
     * @returns
     */
    end(cb) {
        this.res.end(cb);
        return this;
    }
    /**
     * Send the provided message and end the response.
     * Also auto detects if the client is browser and nicely formats the output
     * @param message Content to be sent
     * @param cb
     * @returns
     */
    send(message, cb) {
        if (this.isBrowserRequest) {
            this.setHeader("Content-Type", "text/html");
            this.write((0, htmlTemplate_1.htmlTemplate)(this, message), cb);
        }
        else {
            this.write(message, cb);
        }
        this.end();
        return this;
    }
    /**
     * Set statuscode of the response
     * @param statusCode The status code
     * @returns
     */
    status(statusCode) {
        this.res.statusCode = statusCode;
        return this;
    }
    /**
     * Set status and optionally write some response geaders
     * @param statusCode
     * @param statusMessage
     * @param headers
     * @returns
     */
    writeHead(statusCode, statusMessage, headers) {
        this.res.writeHead(statusCode, statusMessage, headers);
        return this;
    }
    /**
     * Pipe any stream data to the client
     * @param dest A stream to you want to pipe
     * @param opt
     * @returns
     */
    pipe(dest, opt) {
        return this.res.pipe(dest, opt);
    }
    /**
     * Return data as JSON
     * @param data
     * @returns
     */
    json(data) {
        this.set("content-type", "application/json");
        this.send(JSON.stringify(data));
        return this;
    }
    /**
     * Utility to send json and set status success
     * @param data
     * @returns
     */
    success(data) {
        this.status(200).json(data);
        return this;
    }
    /**
     * Send any files to the client
     * @param path Path of the file to be sent
     * @param options Any options
     * @returns
     */
    sendFile(path, options) {
        const file = (0, send_1.default)(this.res.req, encodeURI(path), options);
        file.pipe(this.res);
        return this;
    }
    /**
     * Send and download any file to the client
     * @param filePath Path to the file to be downloaded
     * @param options
     * @returns
     */
    download(filePath, options) {
        this.setHeader("content-disposition", (0, content_disposition_1.default)(filePath));
        return this.sendFile(filePath, options);
    }
}
exports.default = Response;
