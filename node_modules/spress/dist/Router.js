"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const handler_1 = require("./interfaces/handler");
const zod_1 = require("zod");
/**
 * Create new subrouters using
 */
class Router {
    constructor() {
        this.stack = [];
        this.handlers = [];
        this.docs = [];
    }
    addDoc(doc) {
        this.docs.push(doc);
    }
    addEndPointAndDocument(path, method, ...handlers) {
        const type = handler_1.HandlerType.endpoint;
        handlers.forEach((handler) => {
            this.addHandler({ path, method, handler, type });
        });
        this.addDoc({
            path,
            method,
            type,
            handler: handlers.pop(),
            group: "/",
        });
    }
    /**
     * Manually add handler by providing {path, method, type, handler}
     * @param Handler Object with path, type, method and handler
     */
    addHandler({ path, method = handler_1.MethodType.GET, type = handler_1.HandlerType.endpoint, handler, }) {
        this.stack.push({
            path,
            method,
            handler,
            type,
            isRouter: false,
        });
    }
    /**
     * Add sub routers super elegently
     * @param path Path at which you want your router to function
     * @param router The sub router
     * @returns
     */
    addRouter(path, router) {
        this.stack.push({ path, router, isRouter: true });
        router.docs.forEach((doc) => this.addDoc(Object.assign(Object.assign({}, doc), { group: path + doc.group, path: path + doc.path })));
        return this;
    }
    /**
     * Add middlewares to the data flow chain
     * @param middleware An handler function
     * @returns
     */
    use(middleware) {
        this.addHandler({
            path: "/(.*)",
            method: handler_1.MethodType.ALL,
            handler: middleware,
            type: handler_1.HandlerType.middleware,
        });
        return this;
    }
    /**
     * Configure an RPC endpoint
     * You can add input and output validation using zod
     * The method would always be POST
     *
     * @param path
     * @param param1
     * @returns
     */
    rpc(path, { inp = zod_1.z.any(), out = zod_1.z.any(), handler }) {
        const typeSafeHandler = (req, res, next) => {
            try {
                inp.parse(req.body);
                const result = handler(req, res, next);
                out.parse(result);
                res.status(200).json(result);
            }
            catch (e) {
                next(e);
            }
        };
        this.addEndPointAndDocument(path, handler_1.MethodType.POST, typeSafeHandler);
        return this;
    }
    /**
     * A utility method to attach a handler to a path irrespective of the request method
     * @param path The path at which you want to attach the handler
     * @param handlers An array of handlers
     * @returns
     */
    all(path, ...handlers) {
        this.addEndPointAndDocument(path, handler_1.MethodType.ALL, ...handlers);
        return this;
    }
    /**
     * A utility method to attach a `GET` Request handler to a path
     * @param path The path at which you want to attach the handler
     * @param handlers An array of handlers
     * @returns
     */
    get(path, ...handlers) {
        this.addEndPointAndDocument(path, handler_1.MethodType.GET, ...handlers);
        return this;
    }
    /**
     * A utility method to attach a `POST` Request handler to a path
     * @param path The path at which you want to attach the handler
     * @param handlers An array of handlers
     * @returns
     */
    post(path, ...handlers) {
        this.addEndPointAndDocument(path, handler_1.MethodType.POST, ...handlers);
        return this;
    }
    /**
     * A utility method to attach a `PUT` Request handler to a path
     * @param path The path at which you want to attach the handler
     * @param handlers An array of handlers
     * @returns
     */
    put(path, ...handlers) {
        this.addEndPointAndDocument(path, handler_1.MethodType.PUT, ...handlers);
        return this;
    }
    /**
     * A utility method to attach a `PATCH` Request handler to a path
     * @param path The path at which you want to attach the handler
     * @param handlers An array of handlers
     * @returns
     */
    patch(path, ...handlers) {
        this.addEndPointAndDocument(path, handler_1.MethodType.PATCH, ...handlers);
        return this;
    }
    /**
     * A utility method to attach a `DELETE` Request handler to a path
     * @param path The path at which you want to attach the handler
     * @param handlers An array of handlers
     * @returns
     */
    delete(path, ...handlers) {
        this.addEndPointAndDocument(path, handler_1.MethodType.DELETE, ...handlers);
        return this;
    }
    compileHandlers() {
        // flush all handlers (if any)
        this.handlers = [];
        this.stack.forEach((elm) => {
            // If it is a router
            if (elm.isRouter) {
                elm.router.compileHandlers().handlers.forEach((handler) => {
                    this.handlers.push(Object.assign(Object.assign({}, handler), { path: elm.path + handler.path }));
                });
            }
            // for handlers
            else {
                const { isRouter } = elm, handler = __rest(elm, ["isRouter"]);
                this.handlers.push(handler);
            }
        });
        return this;
    }
}
exports.default = Router;
